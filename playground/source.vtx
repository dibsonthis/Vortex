// import io
// import math
// import sdl
// import [] : string

// const vec3 = (x = 0, y = 0, z = 0) => {
//     return {x: x, y: y, z: z}
// }

// const triangle = (a, b, c) => {
//     return {a: a, b: b, c: c}
// }

// const append = (list, value) => {
//     list[list.length()] = value
// }

// const loadObject = (filePath) => {
//     const src = io.readf(filePath)
//     const lines = src.split("\n")

//     var vecs = []
//     var triangles = []

//     for (lines, i, line) {
//         var split_line
//         if (line[0] == "v") {
//             split_line = line.split("")
//             vecs.append(vec3(split_line[1].number(), split_line[2].number(), split_line[3].number()))
//         }
//         else if (line[0] == "f") {
//             split_line = line.split("")
//             triangles.append(triangle(vecs[split_line[1].number() - 1], vecs[split_line[2].number() - 1], vecs[split_line[3].number() - 1]))
//         }
//         // if (line[0] == "v") {
//         //     const vecLine = line.split()
//         //     //var vec = vec3(vecLine[1].number(), vecLine[2].number(), vecLine[3].number())
//         //     //vecs.append(vec)
//         // } else if (line[0] == "f") {
//         //     // const fLine = line.split()
//         //     // var tri = triangle(vecs[fLine[1].number() - 1], vecs[fLine[2].number() - 1], vecs[fLine[3].number() - 1])
//         //     // triangles.append(tri)
//         // }
//     }

//    return { triangles: triangles }
// }

// var init = sdl.initSDL()

// if (init != 0) {
// 	print("Error initializing SDL\n")
// 	exit(1)
// } else {
// 	print("Initialized SDL\n")
// }

// const window = sdl.createWindow("Test", 0, 0, 800, 600)
// const renderer = sdl.createRenderer(window)

// var running = true
// var debug = false
// var xPos = 0
// var yPos = 0

// /* Game Vars */

// var cube = {}

// cube.triangles = [
//     // South
//     triangle(vec3(0, 0, 0), vec3(0, 1, 0), vec3(1, 1, 0)),
//     triangle(vec3(0, 0, 0), vec3(1, 1, 0), vec3(1, 0, 0)),

//     // East
//     triangle(vec3(1, 0, 0), vec3(1, 1, 0), vec3(1, 1, 1)),
//     triangle(vec3(1, 0, 0), vec3(1, 1, 1), vec3(1, 0, 1)),

//     // North
//     triangle(vec3(1, 0, 1), vec3(1, 1, 1), vec3(0, 1, 1)),
//     triangle(vec3(1, 0, 1), vec3(0, 1, 1), vec3(0, 0, 1)),

//     // West
//     triangle(vec3(0, 0, 1), vec3(0, 1, 1), vec3(0, 1, 0)),
//     triangle(vec3(0, 0, 1), vec3(0, 1, 0), vec3(0, 0, 0)),

//     // Top
//     triangle(vec3(0, 1, 0), vec3(0, 1, 1), vec3(1, 1, 1)),
//     triangle(vec3(0, 1, 0), vec3(1, 1, 1), vec3(1, 1, 0)),

//     // Bottom
//     triangle(vec3(1, 0, 1), vec3(0, 0, 1), vec3(0, 0, 0)),
//     triangle(vec3(1, 0, 1), vec3(0, 0, 0), vec3(1, 0, 0))
// ]

// //var object = obj.loadObject("resources/models/teapot.obj")
// var object = cube

// // Projection Matrix

// const fNear = 0.1
// const fFar = 1000
// const fFov = 100
// const fAspectRatio = sdl.getWindowSize(window).h / sdl.getWindowSize(window).w
// const fFovRad = 1 / math.tan(fFov * 0.5 / 180 * 3.14)
// var fTheta = 0

// var vCamera = { x: 0, y: 0, z: 0}

// const matProj = [
//     [fAspectRatio * fFovRad, 0, 0, 0],
//     [0, fFovRad, 0, 0],
//     [0, 0, fFar / (fFar - fNear), 1],
//     [0, 0, (-fFar * fNear) / (fFar - fNear), 0]
// ]

// const multMat4 = (vec, mat) => {
//     var vecOut = {
//         x: vec.x * mat[0][0] + vec.y * mat[1][0] + vec.z * mat[2][0] + mat[3][0],
//         y: vec.x * mat[0][1] + vec.y * mat[1][1] + vec.z * mat[2][1] + mat[3][1],
//         z: vec.x * mat[0][2] + vec.y * mat[1][2] + vec.z * mat[2][2] + mat[3][2]
//     }

//     const w = vec.x * mat[0][3] + vec.y * mat[1][3] + vec.z * mat[2][3] + mat[3][3]

//     if (w != 0) {
//         vecOut.x = vecOut.x / w;
//         vecOut.y = vecOut.y / w;
//         vecOut.z = vecOut.z / w;
//     }

//     return vecOut
// }

// const drawTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
//     sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
//     sdl.drawLine(renderer, x1, y1, x2, y2)
//     sdl.drawLine(renderer, x2, y2, x3, y3)
//     sdl.drawLine(renderer, x3, y3, x1, y1)
// }

// const fillTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
//     sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
//     sdl.drawGeometry(renderer, [
//         {color: color, position: vec3(x1, y1, 0)},
//         {color: color, position: vec3(x2, y2, 0)},
//         {color: color, position: vec3(x3, y3, 0)}
//     ])
// }

// const onQuit = () => {
// 	print("Done\n")
// 	running = false
// }

// const onMouseDown = (event) => {
// }

// const onMouseUp = (event) => {
// }

// const onKeyDown = (event) => {
// 	const keyStr = sdl.getKeyName(event.key.keysm.sym)
// 	if (keyStr == "Escape") {
// 		onQuit()
// 	}
//     if (keyStr == "D") {
//         debug = !debug
//     }
// }

// const onKeyUp = (event) => {
// }

// const onMouseMotion = (event) => {
// 	xPos = event.motion.x
// 	yPos = event.motion.y
// }

// while (running) {
//     var status;
//     while (status != 0) {
//         const poll = sdl.pollEvent()
//         status = poll.status
//         const event = poll.event

//         if (event.type == sdl.EventType.QUIT) {
//             onQuit()
//         }
// 		if (event.type == sdl.EventType.MOUSEBUTTONDOWN) {
// 			onMouseDown(event)
// 		}
// 		if (event.type == sdl.EventType.MOUSEBUTTONUP) {
// 			onMouseUp(event)
// 		}
// 		if (event.type == sdl.EventType.MOUSEMOTION) {
// 			onMouseMotion(event)
// 		}
// 		if (event.type == sdl.EventType.KEYDOWN) {
// 			onKeyDown(event)
// 		}
// 		if (event.type == sdl.EventType.KEYUP) {
// 			onKeyUp(event)
// 		}
// 	}

// 	sdl.renderClear(renderer)

//     /* Render */

//     fTheta += 0.15

//     const matRotZ = [
//         [math.cos(fTheta), math.sin(fTheta), 0, 0],
//         [-math.sin(fTheta), math.cos(fTheta), 0, 0],
//         [0, 0, 1, 0],
//         [0, 0, 0, 1]
//     ]

//     const matRotX = [
//         [1, 0, 0, 0],
//         [0, math.cos(fTheta * 0.5), math.sin(fTheta * 0.5), 0],
//         [0, -math.sin(fTheta * 0.5), math.cos(fTheta * 0.5), 0],
//         [0, 0, 0, 1]
//     ]

//     var trianglesToRender = []

//     for (object.triangles, i, tri) {

//         var cube_color = { r: 0, g: 100, b: 0, a: 255 }

//         var rotatedTri = tri

//         rotatedTri.a = multMat4(rotatedTri.a, matRotZ)
//         rotatedTri.b = multMat4(rotatedTri.b, matRotZ)
//         rotatedTri.c = multMat4(rotatedTri.c, matRotZ)

//         rotatedTri.a = multMat4(rotatedTri.a, matRotX)
//         rotatedTri.b = multMat4(rotatedTri.b, matRotX)
//         rotatedTri.c = multMat4(rotatedTri.c, matRotX)

//         var translatedTri = rotatedTri

//         translatedTri.a.z += 7
//         translatedTri.b.z += 7
//         translatedTri.c.z += 7

//         // Extract Normal

//         const line1 = {
//             x: translatedTri.b.x - translatedTri.a.x,
//             y: translatedTri.b.y - translatedTri.a.y,
//             z: translatedTri.b.z - translatedTri.a.z,
//         }

//         const line2 = {
//             x: translatedTri.c.x - translatedTri.a.x,
//             y: translatedTri.c.y - translatedTri.a.y,
//             z: translatedTri.c.z - translatedTri.a.z,
//         }

//         var normal = {
//             x: line1.y * line2.z - line1.z * line2.y,
//             y: line1.z * line2.x - line1.x * line2.z,
//             z: line1.x * line2.y - line1.y * line2.x,
//         }

//         // Normalise Normal

//         const l = math.sqrt((normal.x ^ 2) + (normal.y ^ 2) + (normal.z ^ 2))
//         normal.x = normal.x / l
//         normal.y = normal.y / l
//         normal.z = normal.z / l

//         const normal_dot_product = 
//             normal.x * (translatedTri.a.x - vCamera.x) +
//             normal.y * (translatedTri.a.y - vCamera.y) +
//             normal.z * (translatedTri.a.z - vCamera.z)

//         if (normal_dot_product < 0) {

//             // Basic light

//             var vLight = { x: 0, y: 0, z: -1}

//             print(vLight, "\n")

//             const lightNormaliser = math.sqrt((vLight.x ^ 2) + (vLight.y ^ 2) + (vLight.z ^ 2))
//             vLight.x = vLight.x / lightNormaliser
//             vLight.y = vLight.y / lightNormaliser
//             vLight.z = vLight.z / lightNormaliser

//             const light_dot_product = 
//             normal.x * (vLight.x - vCamera.x) +
//             normal.y * (vLight.y - vCamera.y) +
//             normal.z * (vLight.z - vCamera.z)

//             // Projection

//             var projectedTri = {
//                 a: multMat4(translatedTri.a, matProj),
//                 b: multMat4(translatedTri.b, matProj),
//                 c: multMat4(translatedTri.c, matProj)
//             }

//             // Scale

//             projectedTri.a.x += 1
//             projectedTri.a.y += 1
//             projectedTri.b.x += 1
//             projectedTri.b.y += 1
//             projectedTri.c.x += 1
//             projectedTri.c.y += 1

//             projectedTri.a.x = projectedTri.a.x * 0.5 * sdl.getWindowSize(window).w
//             projectedTri.a.y = projectedTri.a.y * 0.5 * sdl.getWindowSize(window).h
//             projectedTri.b.x = projectedTri.b.x * 0.5 * sdl.getWindowSize(window).w
//             projectedTri.b.y = projectedTri.b.y * 0.5 * sdl.getWindowSize(window).h
//             projectedTri.c.x = projectedTri.c.x * 0.5 * sdl.getWindowSize(window).w
//             projectedTri.c.y = projectedTri.c.y * 0.5 * sdl.getWindowSize(window).h

//             projectedTri.color = {r: light_dot_product * cube_color.r, g: light_dot_product * cube_color.g, b: light_dot_product * cube_color.b, a: 255}

//             trianglesToRender.append(projectedTri)
//         }
//     }

//     // trianglesToRender = trianglesToRender.sort((t1, t2) => {
//     //     const z1 = (t1.a.z + t1.b.z + t1.c.z) / 3
//     //     const z2 = (t2.a.z + t2.b.z + t2.c.z) / 3
//     //     z1 > z2
//     // })

//     for (trianglesToRender, i, tri) {

//         fillTriangle(
//             renderer,
//             tri.a.x, tri.a.y,
//             tri.b.x, tri.b.y,
//             tri.c.x, tri.c.y,
//             tri.color
//         )

//         if (debug) {
//             drawTriangle(
//                 renderer,
//                 tri.a.x, tri.a.y,
//                 tri.b.x, tri.b.y,
//                 tri.c.x, tri.c.y,
//                 {r: 255, g: 255, b: 255, a: 255}
//             )
//         }
//     }

// 	sdl.setRenderDrawColor(renderer, {r: 0, g: 0, b: 0, a: 255})

// 	sdl.renderPresent(renderer)

// 	//sdl.delay(20)
// }



const x = 10

if (x < 10) {
    const g = 100
    print(g, "\n")
} else if (x > 10) {
    const g = 4.5
    print(g, "\n")
} else {
    const g = 0.005
    print(g, "\n")
}

print(g)


func()